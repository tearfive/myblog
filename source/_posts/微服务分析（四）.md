title: 微服务分析（四）
date: 2018-01-18 14:34:39
tags: SOA

---

## 服务发现的可行方案以及实践案例

看似简单的服务注册和服务目录库管理为何会变得复杂
**其主要原因还是在结合了云端PaaS和docker容器部署后，对于微服务模块部署完成后提供出来的ip地址是在动态变化的**
包括模块在进行动态集群扩展的时候也需要动态接入新的服务提供ip地址
正是由于这个原因引入了服务管理及管理的困难度

#### 现分开描述两种服务发现模式，即客户端发现模式和服务端发现模式

**客户端发现模式**



> 使用客户端发现模式时，客户端决定相应服务实例的网络位置，并且对请求负载均衡。
> 客户端查询服务注册表，后者是一个可用服务实例的数据库；
> 然后使用负载均衡算法从中选择一个实例，并发出请求。
> 客户端从注册服务中查询，其中是所有可用服务实例的库。
> 客户端使用负载均衡算法从多个服务实例中选择出一个，然后发出请求

![](\img\client.png)

**注：这是类似dubbo实现机制一样的两阶段模式，即任何一个服务的消费都需要分两步进行**
###### 第一步是访问服务注册库（更多的而是API Gateway提供）返回一个已经动态均衡后的服务科研地址
###### 第二步是客户端和该地址直接建立连接进行服务消费和访问

**这种模式的实现由两个重点：**
> 其一是动态负载均衡算法
> 其二是服务网关需要对原始服务提供点进行实时的心跳检测以确定服务提供的科研性

###### Netflix OSS是客户端发现模式的绝佳实例。
> Netflix eureka是一个服务注册表，为服务实例注册管理和查询可用实例提供了rest API接口。
> Netflix ribbon是IPC客户端，与eureka一起实现对请求的负载均衡

**缺点：底层的ip虽然动态提供出去了，但是最终仍然暴露了服务消费方，再需要进一步做安全和防火墙隔离的场景下显然是不满足要求的**

**服务端发现模式**

> 客户端通过负载均衡器对某个服务提出请求
> 负载均衡器查询服务注册表，并将请求转发到可用的服务实例
> 如同客户端发现，服务实例在服务注册表中注册或注销，即在服务注册库前新增一个load balancer节点。
**注：这两个节点感觉是可以合并到API Gateway的能力中的**

![](\img\server.png)

服务端发现模式兼具优缺点
> 最大的优点是客户端无需关注发现的细节，只需要简单的负载均衡发送请求
> 这减少了编程语言框架需要完成的发现逻辑，某些部署环境自带这一功能
> 这种模式也有缺点，除非负载均衡器由部署环境提供否则会成为一个需要配置和管理的系统组件

**服务注册表**

> 服务注册需要高可用而且随时更新，客户端缓存从服务注册表中获取到网络地址
> 然而，这些消息最终会过时，客户端也就无法发现服务实例
> 因此，服务注册表会包含若干服务端，使用复杂协议保持一致性

---

> 首先可以看到服务注册表本身不是单点，否则存在单点故障
> 当服务注册表有多台服务器的时候需要考虑服务注册库信息在多台机器上的实时同步和一致
> 我们操作和配置服务注册信息的时候往往只会在一个统一的服务管控端完成

---

> 其次如果服务注册服务器宕机是否一定影响到服务本身的消费和调用
> 如果考虑更高的整体架构可用性，还可以设计对于服务注册库信息在客户端进行缓存
> 当服务注册无法访问的时候可以临时读取本地缓存的服务注册库信息并发起服务访问请求

**对于服务注册表最常用的实现仍然是基于zookeeper进行的**

**etcd**			高可用，分布式，一致性的键值存储，用于共享配置和服务发现
**consul**			发现和配置的服务，提供API实现客户端注册和发现服务
**Apache zookeeper**被分布式应用广泛使用的高性能协调服务

**如前所述，服务实例必须在注册表中注册和注销。注册和注销有两种不同的方法。**

> 方法一是服务实例自己注册。也叫自注册模式（self-registration pattern）
> 另一种是采用管理服务实例注册的其他系统组件，即第三方注册模式

---

> 虽然方法一把服务实例和服务注册表耦合，必须在每个编程语言和框架内实现注册代码
> 但是在自己实现完整的微服务架构中，考虑到PaaS平台下微服务模块的动态部署和扩展
> 采用方法一相对更容易实现
> 但是方法一仍然不能代替服务注册库本身应该具有的服务节点的心跳检测能力