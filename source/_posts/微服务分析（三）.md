title: 微服务（三）
date: 2018-01-18 11:12:44
tags: SOA

---

## 微服务架构中的进程间通信

基于微服务的分布式应用是运行在多态机器上的，一般来说，每个服务实例都是一个进程，因此，服务之间的交互必须通过进程间通信（IPC）来实现

#### 对于微服务架构的交互模式有两个维度

**一对一：**每个客户端请求有一个服务实例来响应
**一对多：**每个客户端请求有多个服务实例来响应

**同步模式：**客户端请求需要服务器即时响应，甚至可能由于等待而阻塞
**异步模式：**客户端请求不会阻塞进程，服务端的响应可是是非即时的

对于同步模式往往只能是一对一，而且还需要等待同步引起阻塞，而对于异步模块往往采用消息机制来实现，同时配合消息中间件可以进一步实现消息的发布订阅。**而对于EDA事件驱动架构要看到其本质也是异步消息中间件和消息的发布订阅**

异步消息机制可以做到最大化的解耦，对于数据CURD的场景可以看到是比较容易通过异步消息机制实现的，但是会进一步引入事务一致性问题，即在采用异步消息机制后往往通过**BASE事务最终一致性**来解决事务层面的问题。而对于查询功能可以看到是比较难通过异步消息API实现的，可以考虑两方面的问题来解决

**其一是服务网关需要具有数据缓存能力，已解决无法从源端获取数据的场景。**
**其二是前端开发框架本身需要支持异步调用和数据装载模式，**特别是对于数据查功能在用户来看在前端的感受仍然需要实时同步的，即通过异步方式返回了查询数据后可以动态刷新前端展示页面

**服务版本的问题：**这是不可避免要遇到的问题，特别是对于RestAPI调用，由于json格式本身无schema返回更加容易忽视了对服务版本的管理和控制。要知道对于json数据格式变化仍然会导致restAPI调用后处理失败。因此服务版本仍然采用大小版本控制比较好

> 对于小版本变更则直接对原有服务进行覆盖的同时对所有受影响的服务消费端进行升级；
> 对于大版本升级则本质是增加一个新服务，而对旧版本服务逐步迁移和替代


**处理局部失败：**之前提到netflix的服务解决方案，对于失败问题的解决要注意常用的仍然是**服务超时设置，断路器机制，流量控制，缓存数据或默认值返回等，**不论采用哪种失败处理策略，都需要考虑应该尽量减少服务调用失败或超时对最终用户造成的影响

#### 基于请求/响应的同步IPC

> 使用同步的，基于请求/响应的IPC机制的时候，客户端向服务端发送请求，服务端处理请求并返回响应。一些客户端会由于等待服务端响应而阻塞
> 而另外一些客户端可能使用异步的基于事件驱动的客户端代码，这些代码可能通过future或者rx observeable封装
> 然而，与消息机制不同，客户端需要响应及时返回

这个模式有很多可选的协议，**但是常见的两个协议是rest和thrift**

thrift能够选择传输协议，包括tcp和HTTP，原始tcp比http更高效，然而http对于防火墙，浏览器和使用者来说更友好。

**由此可见互联网openAPI平台和微服务架构实现中仍然是大量以采用restAPI接口为主**

**对于消息格式的选择**

> 在使用restAPI接口的的时候，更多的是采用了json消息格式而非项目里
> 对于soap web则更多的采用xml消息格式
> 如果采用thrift还可以采用二进制消息格式以提升性能

